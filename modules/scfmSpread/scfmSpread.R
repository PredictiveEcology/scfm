# Everything in this file gets sourced during simInit, and all functions and objects
# are put into the simList. To use objects and functions, use sim$xxx.
defineModule(sim, list(
  name = "scfmSpread",
  description = "model fire spread",
  keywords = c("fire", "spread", "scfm"),
  authors = c(
    person("Steve", "Cumming", email = "stevec@sbf.ulaval.ca", role = "aut"),
    person("Ian", "Eddy", email = "ian.eddy@nrcan-rncan.gc.ca", role = "aut"),
    person("Alex M", "Chubaty", email = "achubaty@for-cast.ca", role = "ctb")
  ),
  childModules = character(),
  version = numeric_version("1.1.0.9002"),
  spatialExtent = raster::extent(rep(NA_real_, 4)),
  timeframe = as.POSIXlt(c(NA, NA)),
  timeunit = "year",
  citation = list("citation.bib"),
  documentation = list("README.txt", "scfmSpread.Rmd"),
  reqdPkgs = list("data.table", "fpCompare", "magrittr", "raster", "reproducible",
                  "SpaDES.tools", "PredictiveEcology/LandR"),
  parameters = rbind(
    defineParameter("neighbours", "numeric", 8, NA, NA,
                    desc = "Number of immediate cell neighbours"),
    defineParameter("pSpread", "numeric", 0.23, 0, 1,
                    desc = "default spread probability if scfmDriverPars is not supplied"),
    defineParameter("returnInterval", "numeric", 1.0, NA, NA,
                    desc = "Time interval between burn events"),
    defineParameter("startTime", "numeric", start(sim), NA, NA,
                    desc = "Simulation time at which to initiate burning"),
    defineParameter(".plotInitialTime", "numeric", start(sim, "year") + 1, NA, NA,
                    desc = "This describes the simulation time at which the first plot event should occur"),
    defineParameter(".plotInterval", "numeric", 1, NA, NA,
                    desc = "This describes the simulation time at which the first plot event should occur"),
    defineParameter(".useCache", "character", c(".inputObjects"), NA, NA,
                    desc = "Internal. Can be names of events or the whole module name; these will be cached by SpaDES")
  ),
  inputObjects = bindrows(
    expectsInput("fireRegimeRas", "RasterLayer", desc = "raster with fire regimes from fireRegimePolys"),
    expectsInput("flammableMap", "RasterLayer", desc = "binary map of landscape flammability"),
    expectsInput("landscapeAttr", "list",
                 desc = "list generated by scfmLandcoverInit with attributes for each polygon"),
    expectsInput("rasterToMatch", "RasterLayer",
                 desc = "template raster for raster GIS operations. Must be supplied by user."),
    expectsInput("scfmDriverPars", "list", desc = "fire modules' parameters"),
    expectsInput("spreadState", "data.table", desc = "see `SpaDES.tools::spread2`")
  ),
  outputObjects = bindrows(
    createsOutput("burnDT", "data.table", desc = "data table with pixel IDs of most recent burn"),
    createsOutput("burnMap", "RasterLayer", desc = "cumulative burn map"),
    createsOutput("burnSummary", "data.table", desc = "describes details of all burned pixels"),
    createsOutput("pSpread", "RasterLayer", desc = "spread probability applied to flammabiliy Map"),
    createsOutput("rstCurrentBurn", "RasterLayer", desc = "annual burn map")
  )
))

## event types
#   - type `init` is required for initialiazation

doEvent.scfmSpread = function(sim, eventTime, eventType, debug = FALSE) {
  switch(
    eventType,
    init = {
      sim <- Init(sim)
      # schedule future event(s)
      sim <- scheduleEvent(sim, P(sim)$startTime, "scfmSpread", "burn", 7.5)

      if ("screen" %in% P(sim)$.plots) {
        sim <- scheduleEvent(sim, P(sim)$.plotInitialTime, "scfmSpread", "plot", eventPriority = .last())
      }
    },
    burn = {
      if (!is.null(sim$spreadState)) {
        ## we really want to test if the data table has any rows
        if (NROW(sim$spreadState[state == "activeSource"]) > 0)
          sim <- Burnemup(sim)
      }
      sim <- scheduleEvent(sim, time(sim) + P(sim)$returnInterval, "scfmSpread", "burn", eventPriority = 7.5)
    },
    plot = {
      if (!is.null(sim$rstCurrentBurn)) {
        Plot(sim$rstCurrentBurn, new = TRUE, col = c("grey", "red"),
             title = paste0("annual burn: year", time(sim)))
        Plot(sim$burnMap, title = "Cumulative Burn", addTo = TRUE)
      }
      sim <- scheduleEvent(sim, eventTime = time(sim) + P(sim)$.plotInterval, "scfmSpread", "plot", eventPriority = 8)
    },
    warning(paste("Undefined event type: '", events(sim)[1, "eventType", with = FALSE],
                  "' in module '", events(sim)[1, "moduleName", with = FALSE], "'", sep = ""))
  )
  return(invisible(sim))
}

Init <- function(sim) {
  compareRaster(sim$rasterToMatch, sim$fireRegimeRas, sim$flammableMap,
                extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE)

  ## better to use fireRegimeRas than flammableMap, or burnMap inherits attributes
  sim$burnMap <- raster(sim$fireRegimeRas)
  sim$burnMap[!is.na(sim$flammableMap[])] <- 0
  sim$burnMap[sim$flammableMap[] %==% 0] <- NA
  if ("scfmDriverPars" %in% ls(sim)) {
    if (length(sim$scfmDriverPars) > 1) {
      pSpread <- raster(sim$flammableMap)
      for (x in names(sim$scfmDriverPars)) {
        pSpread[sim$landscapeAttr[[x]]$cellsByZone] <- sim$scfmDriverPars[[x]]$pSpread
      }
      pSpread[] <- pSpread[] * (sim$flammableMap[])
    } else {
      pSpread <- sim$flammableMap * sim$scfmDriverPars[[1]]$pSpread
    }
  } else {
    pSpread <- P(sim)$pSpread * sim$flammableMap
  }
  sim$pSpread <- pSpread
  #Create empty data table to store each year's burn data
  sim$burnSummary <- data.table("igLoc" = numeric(0),
                                "N" = numeric(0),
                                "year" = numeric(0),
                                "areaBurned" = numeric(0),
                                "polyID" = numeric(0))

  sim$rstCurrentBurn <- raster(sim$fireRegimeRas)
  sim$rstCurrentBurn[sim$flammableMap[] %==% 1] <- 0 # reset annual burn
  sim$rstCurrentBurn[sim$flammableMap[] %==% 0] <- NA # might have to ignore warnings

  return(invisible(sim))
}

## name 'Burnemup' is a homage to Walters and Hillborne
Burnemup <- function(sim) {
  # maxSizes <- unlist(lapply(sim$scfmDriverPars, function(x) x$maxBurnCells))
  # activeLoci <- unique(sim$spreadState$initialLocus) # indices[sim$spreadState$active]
  #we prevent multiple ignitions, which shouldn't happen anyway.

  threadsDT <- data.table::getDTthreads()
  setDTthreads(1)
  on.exit({setDTthreads(threadsDT)}, add = TRUE)

  compareRaster(sim$rasterToMatch, sim$fireRegimeRas, sim$flammableMap,
                extent = TRUE, rowcol = TRUE, crs = TRUE, res = TRUE)

  sim$burnDT <- SpaDES.tools::spread2(sim$flammableMap,
                                      start = sim$spreadState,
                                      spreadProb = sim$pSpread,
                                      #spreadState = sim$spreadState,
                                      directions = P(sim)$neighbours,
                                      # maxSize = maxSizes,  #not sure this works
                                      asRaster = FALSE)

  sim$rstCurrentBurn <- raster(sim$fireRegimeRas) #must wrap with 'raster' to get around file-backed problems
  sim$rstCurrentBurn[sim$flammableMap[] %==% 1] <- 0 #reset annual burn
  sim$rstCurrentBurn[sim$flammableMap[] %==% 0] <- NA #might have to ignore warnings.

  sim$rstCurrentBurn[sim$burnDT$pixels] <- 1 #update annual burn
  sim$rstCurrentBurn@data@attributes <- list("Year" == time(sim))

  sim$burnMap[sim$burnDT$pixels] <- sim$burnMap[sim$burnDT$pixels] + 1 #update cumulative burn
  # sim$burnMap <- setColors(sim$burnMap, value = c("grey", "red"))

  #get fire year, pixels burned, area burned, poly ID of all burned pixels
  tempDT <- sim$burnDT[, .(.N), by = "initialPixels"]
  tempDT$year <- time(sim)
  tempDT$areaBurned <- tempDT$N * sim$landscapeAttr[[1]]$cellSize
  tempDT$polyID <- sim$fireRegimeRas[tempDT$initialPixels]
  setnames(tempDT, c("initialPixels"), c("igLoc"))
  sim$burnSummary <- rbind(sim$burnSummary, tempDT)
  return(invisible(sim))
}

.inputObjects <- function(sim) {
  if (!suppliedElsewhere("fireRegimeRas", sim)) {
    stop("you should run scfmLandCoverInit")
  }

  if (!suppliedElsewhere("flammableMap", sim)) {
    message("you should run scfmIgnition with scfmLandcoverInit")
    flammableMap <- raster(sim$rasterToMatch)
    vals <- sample(x = 0:1, size = ncell(sim$rasterToMatch), replace = TRUE)
    sim$flammmableMap <- setValues(flammableMap, vals)
  }

  return(sim)
}
