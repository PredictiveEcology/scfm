---
title: "scfm"
author: "Ian"
date: "December 18, 2018"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Overview

A fire model created by Dr. Steve Cumming. Parameterizes fire regime from NFDB data, post-fire suppression. 
Does not have vegetation or climate feedbacks. 

```{r load-SpaDES, eval=TRUE}
library(magrittr)
library(raster)
library(SpaDES)
```

## Usage example

```{r module usage example, eval = FALSE}

#Parameters
timeunit <- "year"
times <- list(start = 0, end = 20)
defaultInterval <- 1.0
defaultPlotInterval <- 1.0
defaultInitialSaveTime <- NA #don't be saving nuffink

parameters <- list(
  .progress = list(type = "text", interval = 1),
    scfmLandcoverInit = list(
  .plotInitialTime = times$start,
  .plotInterval = defaultPlotInterval,
  .saveInitialTime = defaultInitialSaveTime,
  .saveInterval = defaultInterval),
  ageModule = list( #age is really time since fire, regardless of landcover
    initialAge = 100,
    maxAge = 200,
    returnInterval = defaultInterval,
    startTime = times$start,
    .plotInitialTime = times$start,
    .plotInterval = defaultPlotInterval,
    .saveInitialTime = defaultInitialSaveTime,
    .saveInterval = defaultInterval),
  scfmIgnition = list(
    pIgnition = 0.0001,
    returnInterval = defaultInterval,
    startTime = times$start,
    .plotInitialTime = NA,
    .plotInterval = defaultPlotInterval,
    .saveInitialTime = defaultInitialSaveTime,
    .saveInterval = defaultInterval),
  scfmEscape = list(
    p0 = 0.05,
    returnInterval = defaultInterval,
    startTime = times$start,
    .plotInitialTime = NA,
    .plotInterval = defaultPlotInterval,
    .saveInitialTime = defaultInitialSaveTime,
    .saveInterval = defaultInterval),
  scfmSpread = list(
    pSpread = 0.235,
    returnInterval = defaultInterval,
    startTime = times$start,
    .plotInitialTime = times$start,
    .plotInterval = defaultPlotInterval,
    .saveInitialTime = defaultInitialSaveTime,
    .saveInterval = defaultInterval),
  scfmRegime = list(fireCause=c("L", "H")),
  scfmDriver = list(targetN = 1000) #this is an important parameter.
  #increase targetN for more robust estimates, longer run-time 
)

modules <- list("group_scfm")

#Paths
paths <- list(
  cachePath = file.path("cache"),
  modulePath = file.path("modules"),
  inputPath = file.path("inputs"),
  outputPath = file.path("outputs")
)
#RasterToMatch:
#if you supply studyArea you should supply rtm to make sure the crs are identical. 
#A default rasterToMatch is provided. However some Spades-Ecosystem modules do not
#require studyArea and rtm to have identical crs, so if running with other spades modules, 
#it is better to create rasterToMatch prior to running SpaDES. 
#To easily generate rtm for your own study area, use PredictiveEcology/LandR::prepInputsLCC, 
#e.g. devtools::install_github("PredictiveEcology/LandR@development") 
#rasterToMatch <- LandR::prepInputsLCC(year = 2005, destinationPath = tempdir(), studyArea = myStudyArea)
#then myStudyArea <- spTransform(myStudyArea, CRSobj = as.character(rasterToMatch@crs))
#Better to reproject the vector to the raster crs to prevent weird cell resolutions

#if run with no studyArea, the default is a small area in southwest Alberta
objects <- list(
  # studyArea = tempStudyArea,
  # rasterToMatch = rtm
  )

#Run module
#The calibration process may take hours (it's cached)
options("reproducible.cachePath" = paths$cachePath) 
options("reproducible.useMemoise" = FALSE)
mySim <- simInit(times = times, params = parameters, modules = modules,
                 objects = objects, paths = paths)

dev()
clearPlot()
set.seed(23657)

outSim <- SpaDES.core::spades(mySim, progress = FALSE, debug = TRUE)
```

```{r module evaluate module output, eval = FALSE}
#for comparing parameters of interest
comparePredictions <- function(polyList, simList) {
  out <- lapply(polyList, FUN = function(x, sim = simList) {
    regime <- sim$scfmRegimePars[[x]]
    driver <- sim$scfmDriverPars[[x]]
    landscapeAttr <- sim$landscapeAttr[[x]]
    firePoints <- outSim$firePoints[outSim$firePoints$PolyID == x,]
    hist_MAAB <- sum(firePoints$SIZE_HA[firePoints$SIZE_HA > landscapeAttr$cellSize])/
      (landscapeAttr$burnyArea*(sim@params$scfmRegime$fireEpoch[2] - sim@params$scfmRegime$fireEpoch[1] + 1))
    #This is a long way of saying, sum of fires/ (flammable landscape * fire epoch )
    #hist_mfs will be NaN if there were no fires larger than one pixel
    pSpread <- driver$pSpread 
    burnSum <- sim$burnSummary[sim$burnSummary$polyID == x,]
    burnSum$N <- as.numeric(burnSum$N)
    burnSum$areaBurned <- as.numeric(burnSum$areaBurned)
    burnSum <- burnSum[burnSum$N > 1]
    mod_MAAB <- sum(burnSum$areaBurned)/(landscapeAttr$burnyArea * (times(sim)$end - times(sim)$start))
    
    pred <- data.frame("PolyId" = x, #Polygon ID
                       "prdMeanSize" = regime$xBar, #The predicted (empirical) mean size of fires
                       "modMeanSize" = mean(burnSum$areaBurned), #The modeled mean size of fires
                       "pSpread" = pSpread, # The spread probability estimated from the SCAM model
                       "hist_MAAB" = hist_MAAB,#The empirical mean annual area burned (from NFDB 1970-2000)
                       "mod_MAAB" = mod_MAAB) #The modelled mean annual area burned
    return(pred)
  })
  return(out)
}

df <- comparePredictions(names(outSim$scfmDriverPars), outSim) %>%
  rbindlist(.)

#Some useful plots
plot(df$modMeanSize ~ df$prdMeanSize, ylab = "modeled mean fire size (ha)", xlab = "empirical mean fire size (ha)", 
     main = "SCFM results for 16 ecoregions in BCR6, NWT")
abline(0,1)

mod_MAAB <- df$mod_MAAB * 100 #percent is better than proportion
hist_MAAB <- df$hist_MAAB * 100
plot(mod_MAAB ~ hist_MAAB, ylab = "modeled mean annual area burned (%)", xlab = "empirical mean annual area burned (%)", main = "SCFM results for 16 ecoregions in BCR6, NWT")
abline(0,1)
