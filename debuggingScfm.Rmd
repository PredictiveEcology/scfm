---
title: "scfm"
author: "Ian Eddy"
date: "Updated May 2023"
output:
  pdf_document: 
    latex_engine: xelatex
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Overview

See `scfm.Rmd` for an overview of the model.

## Usage example

```{r load-packages, eval=TRUE}
if (!"remotes" %in% rownames(installed.packages())) {
  install.packages("remotes")
}

if (!"Require" %in% rownames(installed.packages())) {
  remotes::install_github("PredictiveEcology/Require@development", dependencies = TRUE)
}

if (!"reproducible" %in% rownames(installed.packages())) {
  remotes::install_github("PredictiveEcology/reproducible@development", dependencies = TRUE)
}

if (!"SpaDES.core" %in% rownames(installed.packages())) {
  remotes::install_github("PredictiveEcology/SpaDES.core@development", dependencies = TRUE)
}

library("Require")
Require(c("data.table", "ggplot2",
          "PredictiveEcology/LandR@development",
          "PredictiveEcology/reproducible@development",
          "PredictiveEcology/scfmutils@development",
          "sf",
          "PredictiveEcology/SpaDES.core@development",
          "terra"), upgrade = FALSE)
```

```{r module usage example, eval = FALSE}
paths <- list(
  cachePath = file.path("cache"),
  modulePath = file.path("modules"),
  inputPath = file.path("inputs"),
  outputPath = file.path("outputs")
)

options("reproducible.cachePath" = paths$cachePath) 
options("reproducible.useMemoise" = FALSE)
options("reproducible.useTerra" = TRUE)
options("reproducible.rasterRead" = "terra::rast") ## default

timeunit <- "year"
times <- list(start = 1, end = 10)
defaultPlotInterval <- 50
defaultInitialSaveTime <- NA #don't be saving nuffink

globCache <- c(FALSE)  #don't cache the init event - it is too prone to false positives

parameters <- list(
  scfmLandcoverInit = list(
    .useCache = globCache,
    sliverThreshold = 1e8), #polygons <100 km2 are merged with closest non-sliver neighbour
  scfmIgnition = list(
    .useCache = globCache
  ),
  scfmEscape = list(
    .useCache = globCache, 
    .plotInitialTime = NA
  ),
  scfmSpread = list(
    .useCache = globCache,
    .plotInitialTime = times$start,
    .plotInterval = 20),
  scfmRegime = list(
    .useCache = globCache,
    fireCause=c("L")
  ),
  scfmDriver = list(
    .useCache = globCache,
    .useParallelFireRegimePolys = TRUE,
    targetN = 1000 #increase targetN for more robust estimates, longer run-time
  ),# default targetN = 4000, for reference. 
  scfmDiagnostics = list(
    .studyAreaName = "debug"
  )
)

modules <- list(
  "scfmLandcoverInit", "scfmRegime", "scfmDriver",
  "scfmIgnition", "scfmEscape","scfmSpread",
  "scfmDiagnostics"
)

targetCRS <- paste("+proj=lcc +lat_1=49 +lat_2=77 +lat_0=0 +lon_0=-95 +x_0=0 +y_0=0",
                   "+datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0")

## canonical 'pseudo-random' SA has coords -1209980, 7586865
studyAreaReporting <- terra::vect(cbind(-1209980, 7586865), crs = targetCRS) |>
  SpaDES.tools::randomStudyArea(center = _, size = 10000 * 250 * 30000, seed = 1002) |>
  st_as_sf()
studyArea <- st_buffer(studyAreaReporting, 5000)
studyAreaLarge <- st_buffer(studyArea, 20000)

rasterToMatchLarge <- rast(ext(studyAreaLarge), res = c(250, 250))
crs(rasterToMatchLarge) <- crs(studyAreaLarge)
rasterToMatchLarge[] <- 1
rasterToMatchLarge <- mask(rasterToMatchLarge, studyAreaLarge)

rasterToMatch <- crop(rasterToMatchLarge, studyArea)
rasterToMatch <- mask(rasterToMatch, studyArea)

fireRegimePolysLarge <- prepInputsFireRegimePolys(studyArea = studyAreaLarge, 
                                                  rasterToMatch = rasterToMatchLarge,
                                                  destinationPath = "inputs",
                                                  type = "FRT")

objects <- list(
  studyArea = studyArea,
  studyAreaLarge = studyAreaLarge,
  studyAreaReporting = studyAreaReporting,
  rasterToMatch = rasterToMatch,
  rasterToMatchLarge = rasterToMatchLarge,
  fireRegimePolysLarge = fireRegimePolysLarge
)

outSim <- simInitAndSpades(times = list(start = 1, end = 2500), 
                           params = parameters, 
                           modules = modules,
                           objects = objects, 
                           paths = paths)
```

```{r experiment, eval = FALSE}
#####experiment####

newLandscape <- randomStudyArea(size = 6.25*10000 * 1000 * 1000) ## this is 10k m2/ha * 6.25 ha/pixel * 1000x1000
newLandscape$PolyID <- 139
newLandscape <- st_as_sf(newLandscape)
newLandscapeLarge <- st_buffer(newLandscape, 5e3)
newLandscape <- st_as_sf(newLandscape)
newFlamAreaLarge <- raster(extent(newLandscapeLarge), 
                           crs = crs(newLandscapeLarge), 
                           res = c(250, 250))
newFlamAreaLarge[] <- rbinom(n = ncell(newFlamAreaLarge), size = 1, prob = 0.99)
newFlamAreaLarge <- mask(newFlamAreaLarge, newLandscapeLarge)
newFlamArea <- mask(newFlamAreaLarge, newLandscape)
newLandscapeAttr <- list("139" = outSim$landscapeAttr$`138`)
newLandscapeAttr$`139`$cellsByZone <- which(!is.na(newFlamArea[]))
newRegime <- list("139" = outSim$scfmRegimePars$`139`)
newFireRegimeRas <- newFlamArea
newFireRegimeRas[!is.na(newFireRegimeRas)] <- 139

newObjects <- list("fireRegimePolys" = newLandscape, 
                   "flammableMapLarge" = newFlamAreaLarge,
                   "flammableMap" = newFlamArea,
                   "fireRegimeRas" = newFireRegimeRas,
                   "rasterToMatch" = newFlamArea, 
                   "scfmRegimePars" = newRegime, 
                   "landscapeAttr" = newLandscapeAttr)

outSim <- simInitAndSpades(times = times, 
                           params = parameters, 
                           modules = c("scfmDriver", "scfmIgnition", "scfmEscape", "scfmSpread"),
                           objects = newObjects, 
                           paths = paths)
```

```{r module evaluate module output, eval = FALSE}
## TODO: add these plots as outputs in new scfmSummary module

dt <- scfmutils::comparePredictions_summaryDT(outSim)
  
## Some useful plots
gg_mfs <- scfmutils::comparePredictions_meanFireSize(dt)

# removed MAAB as diagnostic plot because it was derived from fire points incorrectly when SAL is supplied
# MAAB can still be calculated manually if a user desires

gg_fri <- scfmutils::comparePredictions_fireReturnInterval(dt)

gg_ign <- scfmutils::comparePredictions_annualIgnitions(dt)

gg_frp <- scfmutils::plot_fireRegimePolys(outSim$fireRegimePolys)

clearPlot()
gridExtra::grid.arrange(gg_frp,  gg_mfs,  gg_fri,  gg_ign, nrow = 2, ncol = 2)
```
